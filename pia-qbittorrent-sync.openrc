#!/sbin/openrc-run
# OpenRC service file for PIA qBittorrent Sync Service (Alpine Linux)

name="PIA qBittorrent Sync"
description="Automatically updates qBittorrent listening port with PIA port forwarding"

command="/opt/pia-qbittorrent-sync/venv/bin/python3"
command_args="/opt/pia-qbittorrent-sync/pia_qbittorrent_sync.py"
command_background="yes"
pidfile="/run/${RC_SVCNAME}.pid"

# Service dependencies
depend() {
    need net
    after qbittorrent-nox wg-quick.wg0
    use logger
}

# Environment variables
# These can be set in /etc/conf.d/pia-qbittorrent-sync

start_pre() {
    # Create log directory if it doesn't exist
    checkpath --directory --mode 0755 /var/log
    checkpath --file --mode 0644 /var/log/pia_qbittorrent_sync.log
    
    # Create token directory if it doesn't exist
    checkpath --directory --mode 0755 /run/pia
    
    # Check required environment variables
    if [ -z "$PIA_USERNAME" ] || [ -z "$PIA_PASSWORD" ]; then
        eerror "PIA_USERNAME and PIA_PASSWORD must be set in /etc/conf.d/pia-qbittorrent-sync"
        return 1
    fi
    
    if [ -z "$PIA_GATEWAY" ]; then
        eerror "PIA_GATEWAY must be set in /etc/conf.d/pia-qbittorrent-sync"
        return 1
    fi
}

start() {
    ebegin "Starting ${name}"
    start-stop-daemon --start \
        --make-pidfile \
        --pidfile "${pidfile}" \
        --background \
        --stdout /var/log/pia_qbittorrent_sync.log \
        --stderr /var/log/pia_qbittorrent_sync.log \
        --exec "${command}" \
        -- ${command_args}
    eend $?
}

start_post() {
    # Wait for qBittorrent Web UI to be ready before declaring service started
    # Extract host and port from QBITTORRENT_HOST (e.g., http://localhost:8080)
    local qb_host="${QBITTORRENT_HOST:-http://localhost:8080}"
    local qb_port=$(echo "$qb_host" | sed -n 's/.*:\([0-9]\+\).*/\1/p')
    local qb_hostname=$(echo "$qb_host" | sed -n 's|.*://\([^:/]*\).*|\1|p')
    
    # Default to localhost:8080 if parsing fails
    qb_hostname="${qb_hostname:-localhost}"
    qb_port="${qb_port:-8080}"
    
    einfo "Waiting for qBittorrent Web UI at ${qb_hostname}:${qb_port}..."
    
    local retries=30
    local connected=false
    
    # Try to connect using nc if available
    if command -v nc >/dev/null 2>&1; then
        while [ $retries -gt 0 ]; do
            if nc -z "$qb_hostname" "$qb_port" 2>/dev/null; then
                connected=true
                break
            fi
            sleep 1
            retries=$((retries - 1))
        done
    else
        # Fallback: try HTTP request using wget or curl
        while [ $retries -gt 0 ]; do
            if command -v wget >/dev/null 2>&1; then
                if wget -q -O /dev/null --timeout=1 "$qb_host/api/v2/app/version" 2>/dev/null; then
                    connected=true
                    break
                fi
            elif command -v curl >/dev/null 2>&1; then
                if curl -s -f --connect-timeout 1 "$qb_host/api/v2/app/version" >/dev/null 2>&1; then
                    connected=true
                    break
                fi
            else
                # No tools available, skip check with warning
                ewarn "Neither nc, wget, nor curl available to verify qBittorrent readiness"
                return 0
            fi
            sleep 1
            retries=$((retries - 1))
        done
    fi
    
    if [ "$connected" = true ]; then
        einfo "qBittorrent Web UI is ready"
        return 0
    else
        ewarn "qBittorrent Web UI did not become ready in time"
        ewarn "Service may fail to connect initially but will retry"
        return 0  # Don't fail service start, just warn
    fi
}

stop() {
    ebegin "Stopping ${name}"
    start-stop-daemon --stop \
        --pidfile "${pidfile}" \
        --signal SIGTERM \
        --retry 15
    eend $?
}

reload() {
    ebegin "Reloading ${name}"
    start-stop-daemon --signal SIGHUP --pidfile "${pidfile}"
    eend $?
}
